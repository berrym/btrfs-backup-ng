"""Config command: Configuration management."""

import argparse
import logging
import os
import sys
from pathlib import Path
from typing import Any

from ..__logger__ import create_logger
from ..config import ConfigError, find_config_file, load_config
from ..config.loader import generate_example_config
from .common import get_log_level

logger = logging.getLogger(__name__)


def _prompt(message: str, default: str = "") -> str:
    """Prompt user for input with optional default value."""
    if default:
        prompt_text = f"{message} [{default}]: "
    else:
        prompt_text = f"{message}: "

    try:
        value = input(prompt_text).strip()
        return value if value else default
    except (EOFError, KeyboardInterrupt):
        print()
        raise KeyboardInterrupt


def _prompt_bool(message: str, default: bool = True) -> bool:
    """Prompt user for yes/no input."""
    default_str = "Y/n" if default else "y/N"
    prompt_text = f"{message} [{default_str}]: "

    try:
        value = input(prompt_text).strip().lower()
        if not value:
            return default
        return value in ("y", "yes", "true", "1")
    except (EOFError, KeyboardInterrupt):
        print()
        raise KeyboardInterrupt


def _prompt_choice(message: str, choices: list[str], default: str = "") -> str:
    """Prompt user to select from choices."""
    print(f"\n{message}")
    for i, choice in enumerate(choices, 1):
        marker = " *" if choice == default else ""
        print(f"  {i}. {choice}{marker}")

    while True:
        prompt_text = "Enter number or value"
        if default:
            prompt_text += f" [{default}]"
        prompt_text += ": "

        try:
            value = input(prompt_text).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            raise KeyboardInterrupt

        if not value and default:
            return default

        # Try as number
        try:
            idx = int(value) - 1
            if 0 <= idx < len(choices):
                return choices[idx]
        except ValueError:
            pass

        # Try as direct value
        if value in choices:
            return value

        print(f"  Invalid choice. Enter 1-{len(choices)} or a value from the list.")


def _prompt_int(
    message: str, default: int, min_val: int = 0, max_val: int = 100
) -> int:
    """Prompt user for integer input."""
    prompt_text = f"{message} [{default}]: "

    while True:
        try:
            value = input(prompt_text).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            raise KeyboardInterrupt

        if not value:
            return default

        try:
            int_val = int(value)
            if min_val <= int_val <= max_val:
                return int_val
            print(f"  Value must be between {min_val} and {max_val}.")
        except ValueError:
            print("  Please enter a valid number.")


def _generate_config_from_wizard(config_data: dict[str, Any]) -> str:
    """Generate TOML config content from wizard data."""
    lines = [
        "# btrfs-backup-ng configuration",
        "# Generated by config init wizard",
        "",
        "[global]",
        f'snapshot_dir = "{config_data["snapshot_dir"]}"',
        f'timestamp_format = "{config_data["timestamp_format"]}"',
        f"incremental = {str(config_data['incremental']).lower()}",
    ]

    if config_data.get("log_file"):
        lines.append(f'log_file = "{config_data["log_file"]}"')

    if config_data.get("transaction_log"):
        lines.append(f'transaction_log = "{config_data["transaction_log"]}"')

    lines.extend(
        [
            "",
            "# Parallelism settings",
            f"parallel_volumes = {config_data['parallel_volumes']}",
            f"parallel_targets = {config_data['parallel_targets']}",
        ]
    )

    # Retention settings
    retention = config_data.get("retention", {})
    lines.extend(
        [
            "",
            "[global.retention]",
            f'min = "{retention.get("min", "1d")}"',
            f"hourly = {retention.get('hourly', 24)}",
            f"daily = {retention.get('daily', 7)}",
            f"weekly = {retention.get('weekly', 4)}",
            f"monthly = {retention.get('monthly', 12)}",
            f"yearly = {retention.get('yearly', 0)}",
        ]
    )

    # Email notifications
    email = config_data.get("email")
    if email and email.get("enabled"):
        lines.extend(
            [
                "",
                "[global.notifications.email]",
                "enabled = true",
                f'smtp_host = "{email.get("smtp_host", "smtp.example.com")}"',
                f"smtp_port = {email.get('smtp_port', 587)}",
                f'smtp_tls = "{email.get("smtp_tls", "starttls")}"',
            ]
        )
        if email.get("smtp_user"):
            lines.append(f'smtp_user = "{email["smtp_user"]}"')
        if email.get("smtp_password"):
            lines.append(f'smtp_password = "{email["smtp_password"]}"')
        if email.get("from_addr"):
            lines.append(f'from_addr = "{email["from_addr"]}"')
        if email.get("to_addrs"):
            addrs = ", ".join(f'"{a}"' for a in email["to_addrs"])
            lines.append(f"to_addrs = [{addrs}]")
        lines.append(f"on_success = {str(email.get('on_success', False)).lower()}")
        lines.append(f"on_failure = {str(email.get('on_failure', True)).lower()}")

    # Webhook notifications
    webhook = config_data.get("webhook")
    if webhook and webhook.get("enabled"):
        lines.extend(
            [
                "",
                "[global.notifications.webhook]",
                "enabled = true",
                f'url = "{webhook.get("url", "")}"',
                f'method = "{webhook.get("method", "POST")}"',
                f"on_success = {str(webhook.get('on_success', False)).lower()}",
                f"on_failure = {str(webhook.get('on_failure', True)).lower()}",
            ]
        )

    # Volumes
    for volume in config_data.get("volumes", []):
        lines.extend(
            [
                "",
                "[[volumes]]",
                f'path = "{volume["path"]}"',
                f'snapshot_prefix = "{volume["snapshot_prefix"]}"',
            ]
        )

        for target in volume.get("targets", []):
            lines.extend(
                [
                    "",
                    "[[volumes.targets]]",
                    f'path = "{target["path"]}"',
                ]
            )
            if target.get("ssh_sudo"):
                lines.append("ssh_sudo = true")
            if target.get("require_mount"):
                lines.append("require_mount = true")

    lines.append("")
    return "\n".join(lines)


def _run_interactive_wizard() -> str:
    """Run interactive configuration wizard and return TOML content."""
    print()
    print("=" * 60)
    print("  btrfs-backup-ng Configuration Wizard")
    print("=" * 60)
    print()
    print("This wizard will help you create a configuration file.")
    print("Press Ctrl+C at any time to cancel.")
    print()

    config_data: dict[str, Any] = {}

    # Global settings
    print("-" * 40)
    print("  Global Settings")
    print("-" * 40)

    config_data["snapshot_dir"] = _prompt("Snapshot directory name", ".snapshots")

    config_data["timestamp_format"] = _prompt("Timestamp format", "%Y%m%d-%H%M%S")

    config_data["incremental"] = _prompt_bool(
        "Use incremental transfers by default?", True
    )

    config_data["log_file"] = _prompt("Log file path (leave empty to disable)", "")

    config_data["transaction_log"] = _prompt(
        "Transaction log path (leave empty to disable)", ""
    )

    # Parallelism
    print()
    print("-" * 40)
    print("  Parallelism Settings")
    print("-" * 40)

    config_data["parallel_volumes"] = _prompt_int("Max parallel volumes", 2, 1, 16)

    config_data["parallel_targets"] = _prompt_int(
        "Max parallel targets per volume", 3, 1, 16
    )

    # Retention policy
    print()
    print("-" * 40)
    print("  Retention Policy")
    print("-" * 40)
    print()
    print("Configure how long to keep snapshots. Set to 0 to disable.")

    retention: dict[str, str | int] = {}
    retention["min"] = _prompt("Minimum retention period", "1d")
    retention["hourly"] = _prompt_int("Hourly snapshots to keep", 24, 0, 1000)
    retention["daily"] = _prompt_int("Daily snapshots to keep", 7, 0, 1000)
    retention["weekly"] = _prompt_int("Weekly snapshots to keep", 4, 0, 1000)
    retention["monthly"] = _prompt_int("Monthly snapshots to keep", 12, 0, 1000)
    retention["yearly"] = _prompt_int("Yearly snapshots to keep", 0, 0, 1000)
    config_data["retention"] = retention

    # Notifications
    print()
    print("-" * 40)
    print("  Notifications")
    print("-" * 40)

    if _prompt_bool("Configure email notifications?", False):
        email: dict[str, Any] = {"enabled": True}
        email["smtp_host"] = _prompt("SMTP host", "smtp.example.com")
        email["smtp_port"] = _prompt_int("SMTP port", 587, 1, 65535)
        email["smtp_tls"] = _prompt_choice(
            "SMTP security", ["starttls", "ssl", "none"], "starttls"
        )
        email["smtp_user"] = _prompt("SMTP username (leave empty if none)", "")
        if email["smtp_user"]:
            email["smtp_password"] = _prompt("SMTP password", "")
        email["from_addr"] = _prompt("From address", "")
        to_addrs_str = _prompt("To addresses (comma-separated)", "")
        if to_addrs_str:
            email["to_addrs"] = [
                a.strip() for a in to_addrs_str.split(",") if a.strip()
            ]
        email["on_success"] = _prompt_bool("Notify on success?", False)
        email["on_failure"] = _prompt_bool("Notify on failure?", True)
        config_data["email"] = email

    if _prompt_bool("Configure webhook notifications?", False):
        webhook: dict[str, Any] = {"enabled": True}
        webhook["url"] = _prompt("Webhook URL", "")
        webhook["method"] = _prompt_choice(
            "HTTP method", ["POST", "GET", "PUT"], "POST"
        )
        webhook["on_success"] = _prompt_bool("Notify on success?", False)
        webhook["on_failure"] = _prompt_bool("Notify on failure?", True)
        config_data["webhook"] = webhook

    # Volumes
    print()
    print("-" * 40)
    print("  Volumes to Backup")
    print("-" * 40)

    volumes: list[dict[str, Any]] = []
    add_volume = True

    while add_volume:
        print()
        print(f"  Volume #{len(volumes) + 1}")

        volume_path = _prompt("Volume path (e.g., /home)", "")
        if not volume_path:
            if not volumes:
                print("  At least one volume is required.")
                continue
            break

        # Generate default prefix from path
        default_prefix = Path(volume_path).name or "root"
        snapshot_prefix = _prompt("Snapshot prefix", default_prefix)

        volume: dict[str, Any] = {
            "path": volume_path,
            "snapshot_prefix": snapshot_prefix,
            "targets": [],
        }

        # Targets for this volume
        print()
        print("  Add backup targets for this volume:")

        add_target = True
        while add_target:
            target_path = _prompt("  Target path (local or ssh://user@host:/path)", "")
            if not target_path:
                if not volume["targets"]:
                    print("  At least one target is required per volume.")
                    continue
                break

            target: dict[str, Any] = {"path": target_path}

            if target_path.startswith("ssh://"):
                target["ssh_sudo"] = _prompt_bool("  Use sudo on remote host?", False)
            elif target_path.startswith("/mnt/") or "usb" in target_path.lower():
                target["require_mount"] = _prompt_bool(
                    "  Require mount check (for external drives)?", True
                )

            volume["targets"].append(target)
            add_target = _prompt_bool("  Add another target?", False)

        volumes.append(volume)
        add_volume = _prompt_bool("Add another volume?", False)

    config_data["volumes"] = volumes

    # Generate the config
    print()
    print("-" * 40)
    print("  Configuration Complete")
    print("-" * 40)

    return _generate_config_from_wizard(config_data)


def execute_config(args: argparse.Namespace) -> int:
    """Execute the config command.

    Args:
        args: Parsed command line arguments

    Returns:
        Exit code
    """
    log_level = get_log_level(args)
    create_logger(False, level=log_level)

    action = getattr(args, "config_action", None)

    if action == "validate":
        return _validate_config(args)
    elif action == "init":
        return _init_config(args)
    elif action == "import":
        return _import_config(args)
    elif action == "detect":
        return _detect_subvolumes(args)
    else:
        print("Usage: btrfs-backup-ng config <validate|init|import|detect>")
        return 1


def _validate_config(args: argparse.Namespace) -> int:
    """Validate configuration file."""
    try:
        config_path = find_config_file(getattr(args, "config", None))
        if config_path is None:
            print("No configuration file found.")
            print("Searched locations:")
            print("  ~/.config/btrfs-backup-ng/config.toml")
            print("  /etc/btrfs-backup-ng/config.toml")
            return 1

        print(f"Validating: {config_path}")
        config, warnings = load_config(config_path)

        if warnings:
            print("")
            print("Warnings:")
            for warning in warnings:
                print(f"  - {warning}")

        print("")
        print("Configuration is valid.")
        print(f"  Volumes: {len(config.volumes)}")
        print(f"  Enabled: {len(config.get_enabled_volumes())}")

        total_targets = sum(len(v.targets) for v in config.volumes)
        print(f"  Targets: {total_targets}")

        return 0

    except ConfigError as e:
        print(f"Configuration error: {e}")
        return 1


def _init_config(args: argparse.Namespace) -> int:
    """Generate example configuration."""
    interactive = getattr(args, "interactive", False)
    output = getattr(args, "output", None)

    if interactive:
        # Check if stdout is a TTY for interactive mode
        if not sys.stdin.isatty():
            print("Error: Interactive mode requires a terminal (TTY)")
            return 1

        try:
            content = _run_interactive_wizard()
        except KeyboardInterrupt:
            print("\nConfiguration cancelled.")
            return 1
    else:
        content = generate_example_config()

    if output:
        # Check if file exists
        if os.path.exists(output) and interactive:
            if not _prompt_bool(f"\nFile {output} exists. Overwrite?", False):
                print("Aborted.")
                return 1

        try:
            with open(output, "w") as f:
                f.write(content)
            if interactive:
                print(f"\nConfiguration written to: {output}")
                print("Review and adjust the configuration, then run:")
                print(f"  btrfs-backup-ng config validate --config {output}")
            else:
                print(f"Example configuration written to: {output}")
        except OSError as e:
            print(f"Error writing file: {e}")
            return 1
    else:
        print(content)

    return 0


def _import_config(args: argparse.Namespace) -> int:
    """Import btrbk configuration."""
    from ..btrbk_import import import_btrbk_config

    btrbk_file = getattr(args, "btrbk_config", None)
    if not btrbk_file:
        print("Error: btrbk configuration file path required")
        return 1

    try:
        toml_content, warnings = import_btrbk_config(btrbk_file)
    except FileNotFoundError as e:
        print(f"Error: {e}")
        return 1
    except Exception as e:
        print(f"Error parsing btrbk config: {e}")
        return 1

    # Show warnings
    if warnings:
        print("# Conversion warnings:", file=sys.stderr)
        for warning in warnings:
            print(f"#   {warning}", file=sys.stderr)
        print("", file=sys.stderr)

    # Output TOML
    output = getattr(args, "output", None)
    if output:
        try:
            with open(output, "w") as f:
                f.write(toml_content)
            print(f"Configuration written to: {output}", file=sys.stderr)
            print("Review the file and adjust as needed.", file=sys.stderr)
        except OSError as e:
            print(f"Error writing file: {e}")
            return 1
    else:
        print(toml_content)

    if warnings:
        print("", file=sys.stderr)
        print(f"Conversion complete with {len(warnings)} warning(s).", file=sys.stderr)
        print(
            "Review the warnings above and adjust the configuration.", file=sys.stderr
        )

    return 0


def _detect_subvolumes(args: argparse.Namespace) -> int:
    """Detect btrfs subvolumes on the system.

    Args:
        args: Parsed command line arguments with:
            - json: Output in JSON format
            - wizard: Launch interactive wizard with detected volumes

    Returns:
        Exit code (0 for success, 1 for error)
    """
    import json as json_module

    from ..detection import (
        DetectionError,
        PermissionDeniedError,
        detect_subvolumes,
    )

    json_output = getattr(args, "json", False)
    wizard = getattr(args, "wizard", False)

    # Try full detection first
    try:
        result = detect_subvolumes(allow_partial=False)
    except PermissionDeniedError:
        # Offer fallback for non-root users
        if json_output:
            # In JSON mode, just do partial detection
            result = detect_subvolumes(allow_partial=True)
        else:
            print("For complete subvolume detection, root privileges are required.")
            print()
            print("  Run: sudo btrfs-backup-ng config detect")
            print()

            if sys.stdin.isatty():
                try:
                    if _prompt_bool("Continue with limited detection?", False):
                        result = detect_subvolumes(allow_partial=True)
                    else:
                        return 1
                except KeyboardInterrupt:
                    print("\nCancelled.")
                    return 1
            else:
                # Non-interactive, just fail
                return 1
    except DetectionError as e:
        print(f"Detection error: {e}")
        return 1

    # Handle no btrfs filesystems
    if not result.filesystems:
        if json_output:
            print(json_module.dumps(result.to_dict(), indent=2))
        else:
            print("No btrfs filesystems found on this system.")
            print()
            print("btrfs-backup-ng requires btrfs subvolumes to back up.")
            print("You can still create a configuration manually with:")
            print("  btrfs-backup-ng config init")
        return 1

    # JSON output mode
    if json_output:
        print(json_module.dumps(result.to_dict(), indent=2))
        return 0

    # Wizard mode
    if wizard:
        if not sys.stdin.isatty():
            print("Error: Wizard mode requires a terminal (TTY)")
            return 1
        return _run_detection_wizard(result)

    # Default: Display detection results
    _display_detection_results(result)
    return 0


def _display_detection_results(result) -> None:
    """Display detection results in a human-readable format.

    Args:
        result: DetectionResult from detect_subvolumes()
    """
    from ..detection import SubvolumeClass

    print()
    print("=" * 60)
    print("  Btrfs Subvolume Detection Results")
    print("=" * 60)

    if result.is_partial:
        print()
        print(f"  Note: {result.error_message}")
        print("  Results may be incomplete.")

    print()
    print(f"Found {len(result.filesystems)} btrfs filesystem(s)")
    print(f"Found {len(result.subvolumes)} subvolume(s)")
    print()

    # Recommended for backup
    recommended = [s for s in result.suggestions if s.is_recommended]
    if recommended:
        print("-" * 40)
        print("  Recommended for backup:")
        print("-" * 40)
        for i, suggestion in enumerate(recommended, 1):
            sv = suggestion.subvolume
            classification = sv.classification.value.replace("_", " ")
            print(f"  [{i}] {sv.display_path}")
            print(f"      Type: {classification}")
            print(f"      Suggested prefix: {suggestion.suggested_prefix}")
            print()

    # Optional
    optional = [s for s in result.suggestions if not s.is_recommended]
    if optional:
        print("-" * 40)
        print("  Optional (lower priority):")
        print("-" * 40)
        for suggestion in optional:
            sv = suggestion.subvolume
            classification = sv.classification.value.replace("_", " ")
            print(f"  - {sv.display_path} ({classification})")
        print()

    # Excluded
    excluded = result.excluded_subvolumes
    if excluded:
        print("-" * 40)
        print("  Excluded (snapshots/system):")
        print("-" * 40)
        # Group by classification
        snapshots = [
            sv for sv in excluded if sv.classification == SubvolumeClass.SNAPSHOT
        ]
        internal = [
            sv for sv in excluded if sv.classification == SubvolumeClass.INTERNAL
        ]

        if snapshots:
            if len(snapshots) <= 5:
                for sv in snapshots:
                    print(f"  - {sv.path} (snapshot)")
            else:
                print(f"  - {len(snapshots)} snapshot subvolumes")

        if internal:
            for sv in internal:
                print(f"  - {sv.path} (system internal)")
        print()

    # Next steps
    print("-" * 40)
    print("  Next steps:")
    print("-" * 40)
    print("  To create a configuration based on these results:")
    print("    btrfs-backup-ng config detect --wizard")
    print()
    print("  Or create a configuration manually:")
    print("    btrfs-backup-ng config init --interactive")
    print()


def _run_detection_wizard(result) -> int:
    """Run interactive wizard with pre-populated detection results.

    Args:
        result: DetectionResult from detect_subvolumes()

    Returns:
        Exit code
    """

    print()
    print("=" * 60)
    print("  Detection-based Configuration Wizard")
    print("=" * 60)
    print()
    print("This wizard will help you create a backup configuration")
    print("based on detected btrfs subvolumes.")
    print("Press Ctrl+C at any time to cancel.")
    print()

    if result.is_partial:
        print(f"Note: {result.error_message}")
        print("Results may be incomplete.")
        print()

    # Step 1: Select volumes to back up
    print("-" * 40)
    print("  Detected Subvolumes")
    print("-" * 40)
    print()

    # Build list of selectable volumes (exclude snapshots and internal)
    selectable = []
    for suggestion in result.suggestions:
        sv = suggestion.subvolume
        selectable.append((suggestion, sv))

    if not selectable:
        print("No subvolumes suitable for backup were detected.")
        print("You may need to run with sudo for complete detection.")
        return 1

    # Display with numbers
    print("  Recommended for backup:")
    recommended_indices = []
    for i, (suggestion, sv) in enumerate(selectable, 1):
        marker = "*" if suggestion.is_recommended else " "
        classification = sv.classification.value.replace("_", " ")
        print(f"  [{i}]{marker} {sv.display_path} ({classification})")
        if suggestion.is_recommended:
            recommended_indices.append(str(i))

    print()
    print("  * = recommended")
    print()

    # Let user select
    default_selection = ",".join(recommended_indices) if recommended_indices else "1"
    selection_str = _prompt(
        "Select volumes to back up (comma-separated numbers, or 'all')",
        default_selection,
    )

    # Parse selection
    selected_volumes = []
    if selection_str.lower() == "all":
        selected_volumes = [s for s, _ in selectable]
    else:
        try:
            indices = [int(x.strip()) for x in selection_str.split(",") if x.strip()]
            for idx in indices:
                if 1 <= idx <= len(selectable):
                    selected_volumes.append(selectable[idx - 1][0])
                else:
                    print(f"  Warning: {idx} is not a valid selection, skipping")
        except ValueError:
            print("Invalid selection. Using recommended volumes.")
            selected_volumes = [s for s, _ in selectable if s.is_recommended]

    if not selected_volumes:
        print("No volumes selected. Exiting.")
        return 1

    print()
    print(f"Selected {len(selected_volumes)} volume(s) for backup.")
    print()

    # Step 2: Configure each volume
    config_data: dict[str, Any] = {
        "snapshot_dir": ".snapshots",
        "timestamp_format": "%Y%m%d-%H%M%S",
        "incremental": True,
        "log_file": "",
        "transaction_log": "",
        "parallel_volumes": 2,
        "parallel_targets": 3,
        "retention": {
            "min": "1d",
            "hourly": 24,
            "daily": 7,
            "weekly": 4,
            "monthly": 12,
            "yearly": 0,
        },
        "volumes": [],
    }

    for suggestion in selected_volumes:
        sv = suggestion.subvolume
        print("-" * 40)
        print(f"  Volume: {sv.display_path}")
        print("-" * 40)

        volume: dict[str, Any] = {
            "path": sv.display_path,
            "snapshot_prefix": _prompt("Snapshot prefix", suggestion.suggested_prefix),
            "targets": [],
        }

        # Add targets
        print()
        print("  Add backup target(s) for this volume:")
        add_target = True
        while add_target:
            target_path = _prompt(
                "  Target path (local path or ssh://user@host:/path)", ""
            )
            if not target_path:
                if not volume["targets"]:
                    print("  At least one target is required per volume.")
                    continue
                break

            target: dict[str, Any] = {"path": target_path}

            if target_path.startswith("ssh://"):
                target["ssh_sudo"] = _prompt_bool("  Use sudo on remote host?", False)
            elif target_path.startswith("/mnt/") or "usb" in target_path.lower():
                target["require_mount"] = _prompt_bool(
                    "  Require mount check (for external drives)?", True
                )

            volume["targets"].append(target)
            print(f"  Added target: {target_path}")
            add_target = _prompt_bool("  Add another target?", False)

        config_data["volumes"].append(volume)
        print()

    # Step 3: Global settings (optional)
    print("-" * 40)
    print("  Global Settings")
    print("-" * 40)
    print()

    if _prompt_bool("Configure global settings (retention, notifications)?", False):
        # Retention
        print()
        print("  Retention Policy:")
        retention = config_data["retention"]
        retention["min"] = _prompt("  Minimum retention period", "1d")
        retention["hourly"] = _prompt_int("  Hourly snapshots to keep", 24, 0, 1000)
        retention["daily"] = _prompt_int("  Daily snapshots to keep", 7, 0, 1000)
        retention["weekly"] = _prompt_int("  Weekly snapshots to keep", 4, 0, 1000)
        retention["monthly"] = _prompt_int("  Monthly snapshots to keep", 12, 0, 1000)
        retention["yearly"] = _prompt_int("  Yearly snapshots to keep", 0, 0, 1000)

        # Email notifications
        print()
        if _prompt_bool("  Configure email notifications?", False):
            email: dict[str, Any] = {"enabled": True}
            email["smtp_host"] = _prompt("  SMTP host", "smtp.example.com")
            email["smtp_port"] = _prompt_int("  SMTP port", 587, 1, 65535)
            email["smtp_tls"] = _prompt_choice(
                "  SMTP security", ["starttls", "ssl", "none"], "starttls"
            )
            email["smtp_user"] = _prompt("  SMTP username (leave empty if none)", "")
            if email["smtp_user"]:
                email["smtp_password"] = _prompt("  SMTP password", "")
            email["from_addr"] = _prompt("  From address", "")
            to_addrs_str = _prompt("  To addresses (comma-separated)", "")
            if to_addrs_str:
                email["to_addrs"] = [
                    a.strip() for a in to_addrs_str.split(",") if a.strip()
                ]
            email["on_success"] = _prompt_bool("  Notify on success?", False)
            email["on_failure"] = _prompt_bool("  Notify on failure?", True)
            config_data["email"] = email
    else:
        print("  Using default settings (can be changed later in config file).")

    print()

    # Step 4: Generate config
    new_config = _generate_config_from_wizard(config_data)

    # Step 5: Check for existing config and show diff if needed
    existing_config_path = find_config_file(None)
    existing_content = None

    if existing_config_path:
        try:
            existing_content = Path(existing_config_path).read_text()
        except OSError:
            existing_content = None

    if existing_content:
        print("-" * 40)
        print("  Existing Configuration Found")
        print("-" * 40)
        print()
        print(f"  Found: {existing_config_path}")
        print()

        # Offer diff view
        view_diff = _prompt_bool("View changes compared to existing config?", True)
        if view_diff:
            diff_format = _prompt_choice(
                "Diff format",
                ["summary", "text"],
                "summary",
            )
            print()
            if diff_format == "summary":
                _show_config_diff_summary(existing_content, new_config, config_data)
            else:
                _show_config_diff_text(existing_content, new_config)
            print()

    # Step 6: Save options
    print("-" * 40)
    print("  Save Configuration")
    print("-" * 40)
    print()

    save_choice = _prompt_choice(
        "What would you like to do?",
        ["save", "print", "cancel"],
        "save",
    )

    if save_choice == "cancel":
        print()
        print("Configuration cancelled.")
        return 0

    if save_choice == "print":
        print()
        print("-" * 40)
        print("  Generated Configuration")
        print("-" * 40)
        print()
        print(new_config)
        return 0

    # Save to file
    if existing_config_path:
        default_path = str(existing_config_path)
        print()
        print(f"  Existing config: {existing_config_path}")
        save_path = _prompt(
            "Save to (enter new path to keep existing, or same to overwrite)",
            default_path,
        )
    else:
        default_path = str(Path.home() / ".config/btrfs-backup-ng/config.toml")
        save_path = _prompt("Save configuration to", default_path)

    # Create directory if needed
    save_file = Path(save_path)
    try:
        save_file.parent.mkdir(parents=True, exist_ok=True)

        # Check for overwrite
        if save_file.exists():
            if not _prompt_bool(f"Overwrite {save_path}?", False):
                print("Save cancelled.")
                return 0

        save_file.write_text(new_config)
        print()
        print(f"Configuration saved to: {save_path}")
        print()
        print("Next steps:")
        print(f"  1. Review: btrfs-backup-ng config validate -c {save_path}")
        print(f"  2. Test:   btrfs-backup-ng run --dry-run -c {save_path}")
        print(f"  3. Install timer: btrfs-backup-ng install -c {save_path}")

    except OSError as e:
        print(f"Error saving configuration: {e}")
        return 1

    return 0


def _show_config_diff_summary(
    existing: str, new: str, config_data: dict[str, Any]
) -> None:
    """Show a human-friendly summary of config changes.

    Args:
        existing: Existing config content
        new: New config content
        config_data: Parsed config data from wizard
    """
    print("  Changes:")
    print()

    # Parse existing config to compare
    try:
        import tomllib

        existing_parsed = tomllib.loads(existing)
    except Exception:
        print("  (Could not parse existing config for comparison)")
        print("  New configuration will replace existing.")
        return

    # Compare volumes
    existing_volumes = {v.get("path"): v for v in existing_parsed.get("volumes", [])}
    new_volumes = {v["path"]: v for v in config_data.get("volumes", [])}

    # Added volumes
    for path in new_volumes:
        if path not in existing_volumes:
            prefix = new_volumes[path].get("snapshot_prefix", "")
            targets = len(new_volumes[path].get("targets", []))
            print(f"  + Add volume: {path}")
            print(f"      prefix: {prefix}, targets: {targets}")

    # Removed volumes
    for path in existing_volumes:
        if path not in new_volumes:
            print(f"  - Remove volume: {path}")

    # Modified volumes
    for path in new_volumes:
        if path in existing_volumes:
            old = existing_volumes[path]
            new_v = new_volumes[path]
            changes = []

            if old.get("snapshot_prefix") != new_v.get("snapshot_prefix"):
                changes.append(
                    f"prefix: {old.get('snapshot_prefix')} -> "
                    f"{new_v.get('snapshot_prefix')}"
                )

            old_targets = len(old.get("targets", []))
            new_targets = len(new_v.get("targets", []))
            if old_targets != new_targets:
                changes.append(f"targets: {old_targets} -> {new_targets}")

            if changes:
                print(f"  ~ Modify volume: {path}")
                for change in changes:
                    print(f"      {change}")

    # Compare retention
    old_retention = existing_parsed.get("global", {}).get("retention", {})
    new_retention = config_data.get("retention", {})

    retention_changes = []
    for key in ["min", "hourly", "daily", "weekly", "monthly", "yearly"]:
        old_val = old_retention.get(key)
        new_val = new_retention.get(key)
        if old_val != new_val and new_val is not None:
            retention_changes.append(f"{key}: {old_val} -> {new_val}")

    if retention_changes:
        print("  ~ Modify retention:")
        for change in retention_changes:
            print(f"      {change}")

    # Check for notification changes
    if config_data.get("email") and not existing_parsed.get("global", {}).get(
        "notifications", {}
    ).get("email"):
        print("  + Add email notifications")

    if config_data.get("webhook") and not existing_parsed.get("global", {}).get(
        "notifications", {}
    ).get("webhook"):
        print("  + Add webhook notifications")


def _show_config_diff_text(existing: str, new: str) -> None:
    """Show a text-based diff of config changes.

    Args:
        existing: Existing config content
        new: New config content
    """
    import difflib

    existing_lines = existing.splitlines(keepends=True)
    new_lines = new.splitlines(keepends=True)

    diff = difflib.unified_diff(
        existing_lines,
        new_lines,
        fromfile="existing config",
        tofile="new config",
        lineterm="",
    )

    diff_output = list(diff)
    if not diff_output:
        print("  No differences detected.")
        return

    print("  " + "-" * 38)
    for line in diff_output:
        line = line.rstrip("\n")
        if line.startswith("+") and not line.startswith("+++"):
            print(f"  {line}")
        elif line.startswith("-") and not line.startswith("---"):
            print(f"  {line}")
        elif line.startswith("@@"):
            print(f"  {line}")
        elif line.startswith("---") or line.startswith("+++"):
            print(f"  {line}")
    print("  " + "-" * 38)
