"""Config command: Configuration management."""

import argparse
import logging
import os
import sys
from pathlib import Path
from typing import Any

from ..__logger__ import create_logger
from ..config import ConfigError, find_config_file, load_config
from ..config.loader import generate_example_config
from .common import get_log_level

logger = logging.getLogger(__name__)


def _prompt(message: str, default: str = "") -> str:
    """Prompt user for input with optional default value."""
    if default:
        prompt_text = f"{message} [{default}]: "
    else:
        prompt_text = f"{message}: "

    try:
        value = input(prompt_text).strip()
        return value if value else default
    except (EOFError, KeyboardInterrupt):
        print()
        raise KeyboardInterrupt


def _prompt_bool(message: str, default: bool = True) -> bool:
    """Prompt user for yes/no input."""
    default_str = "Y/n" if default else "y/N"
    prompt_text = f"{message} [{default_str}]: "

    try:
        value = input(prompt_text).strip().lower()
        if not value:
            return default
        return value in ("y", "yes", "true", "1")
    except (EOFError, KeyboardInterrupt):
        print()
        raise KeyboardInterrupt


def _prompt_choice(message: str, choices: list[str], default: str = "") -> str:
    """Prompt user to select from choices."""
    print(f"\n{message}")
    for i, choice in enumerate(choices, 1):
        marker = " *" if choice == default else ""
        print(f"  {i}. {choice}{marker}")

    while True:
        prompt_text = "Enter number or value"
        if default:
            prompt_text += f" [{default}]"
        prompt_text += ": "

        try:
            value = input(prompt_text).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            raise KeyboardInterrupt

        if not value and default:
            return default

        # Try as number
        try:
            idx = int(value) - 1
            if 0 <= idx < len(choices):
                return choices[idx]
        except ValueError:
            pass

        # Try as direct value
        if value in choices:
            return value

        print(f"  Invalid choice. Enter 1-{len(choices)} or a value from the list.")


def _prompt_int(
    message: str, default: int, min_val: int = 0, max_val: int = 100
) -> int:
    """Prompt user for integer input."""
    prompt_text = f"{message} [{default}]: "

    while True:
        try:
            value = input(prompt_text).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            raise KeyboardInterrupt

        if not value:
            return default

        try:
            int_val = int(value)
            if min_val <= int_val <= max_val:
                return int_val
            print(f"  Value must be between {min_val} and {max_val}.")
        except ValueError:
            print("  Please enter a valid number.")


def _generate_config_from_wizard(config_data: dict[str, Any]) -> str:
    """Generate TOML config content from wizard data."""
    lines = [
        "# btrfs-backup-ng configuration",
        "# Generated by config init wizard",
        "",
        "[global]",
        f'snapshot_dir = "{config_data["snapshot_dir"]}"',
        f'timestamp_format = "{config_data["timestamp_format"]}"',
        f"incremental = {str(config_data['incremental']).lower()}",
    ]

    if config_data.get("log_file"):
        lines.append(f'log_file = "{config_data["log_file"]}"')

    if config_data.get("transaction_log"):
        lines.append(f'transaction_log = "{config_data["transaction_log"]}"')

    lines.extend(
        [
            "",
            "# Parallelism settings",
            f"parallel_volumes = {config_data['parallel_volumes']}",
            f"parallel_targets = {config_data['parallel_targets']}",
        ]
    )

    # Retention settings
    retention = config_data.get("retention", {})
    lines.extend(
        [
            "",
            "[global.retention]",
            f'min = "{retention.get("min", "1d")}"',
            f"hourly = {retention.get('hourly', 24)}",
            f"daily = {retention.get('daily', 7)}",
            f"weekly = {retention.get('weekly', 4)}",
            f"monthly = {retention.get('monthly', 12)}",
            f"yearly = {retention.get('yearly', 0)}",
        ]
    )

    # Email notifications
    email = config_data.get("email")
    if email and email.get("enabled"):
        lines.extend(
            [
                "",
                "[global.notifications.email]",
                "enabled = true",
                f'smtp_host = "{email.get("smtp_host", "smtp.example.com")}"',
                f"smtp_port = {email.get('smtp_port', 587)}",
                f'smtp_tls = "{email.get("smtp_tls", "starttls")}"',
            ]
        )
        if email.get("smtp_user"):
            lines.append(f'smtp_user = "{email["smtp_user"]}"')
        if email.get("smtp_password"):
            lines.append(f'smtp_password = "{email["smtp_password"]}"')
        if email.get("from_addr"):
            lines.append(f'from_addr = "{email["from_addr"]}"')
        if email.get("to_addrs"):
            addrs = ", ".join(f'"{a}"' for a in email["to_addrs"])
            lines.append(f"to_addrs = [{addrs}]")
        lines.append(f"on_success = {str(email.get('on_success', False)).lower()}")
        lines.append(f"on_failure = {str(email.get('on_failure', True)).lower()}")

    # Webhook notifications
    webhook = config_data.get("webhook")
    if webhook and webhook.get("enabled"):
        lines.extend(
            [
                "",
                "[global.notifications.webhook]",
                "enabled = true",
                f'url = "{webhook.get("url", "")}"',
                f'method = "{webhook.get("method", "POST")}"',
                f"on_success = {str(webhook.get('on_success', False)).lower()}",
                f"on_failure = {str(webhook.get('on_failure', True)).lower()}",
            ]
        )

    # Volumes
    for volume in config_data.get("volumes", []):
        lines.extend(
            [
                "",
                "[[volumes]]",
                f'path = "{volume["path"]}"',
                f'snapshot_prefix = "{volume["snapshot_prefix"]}"',
            ]
        )

        for target in volume.get("targets", []):
            lines.extend(
                [
                    "",
                    "[[volumes.targets]]",
                    f'path = "{target["path"]}"',
                ]
            )
            if target.get("ssh_sudo"):
                lines.append("ssh_sudo = true")
            if target.get("require_mount"):
                lines.append("require_mount = true")

    lines.append("")
    return "\n".join(lines)


def _run_interactive_wizard() -> str:
    """Run interactive configuration wizard and return TOML content."""
    print()
    print("=" * 60)
    print("  btrfs-backup-ng Configuration Wizard")
    print("=" * 60)
    print()
    print("This wizard will help you create a configuration file.")
    print("Press Ctrl+C at any time to cancel.")
    print()

    config_data: dict[str, Any] = {}

    # Global settings
    print("-" * 40)
    print("  Global Settings")
    print("-" * 40)

    config_data["snapshot_dir"] = _prompt("Snapshot directory name", ".snapshots")

    config_data["timestamp_format"] = _prompt("Timestamp format", "%Y%m%d-%H%M%S")

    config_data["incremental"] = _prompt_bool(
        "Use incremental transfers by default?", True
    )

    config_data["log_file"] = _prompt("Log file path (leave empty to disable)", "")

    config_data["transaction_log"] = _prompt(
        "Transaction log path (leave empty to disable)", ""
    )

    # Parallelism
    print()
    print("-" * 40)
    print("  Parallelism Settings")
    print("-" * 40)

    config_data["parallel_volumes"] = _prompt_int("Max parallel volumes", 2, 1, 16)

    config_data["parallel_targets"] = _prompt_int(
        "Max parallel targets per volume", 3, 1, 16
    )

    # Retention policy
    print()
    print("-" * 40)
    print("  Retention Policy")
    print("-" * 40)
    print()
    print("Configure how long to keep snapshots. Set to 0 to disable.")

    retention = {}
    retention["min"] = _prompt("Minimum retention period", "1d")
    retention["hourly"] = _prompt_int("Hourly snapshots to keep", 24, 0, 1000)
    retention["daily"] = _prompt_int("Daily snapshots to keep", 7, 0, 1000)
    retention["weekly"] = _prompt_int("Weekly snapshots to keep", 4, 0, 1000)
    retention["monthly"] = _prompt_int("Monthly snapshots to keep", 12, 0, 1000)
    retention["yearly"] = _prompt_int("Yearly snapshots to keep", 0, 0, 1000)
    config_data["retention"] = retention

    # Notifications
    print()
    print("-" * 40)
    print("  Notifications")
    print("-" * 40)

    if _prompt_bool("Configure email notifications?", False):
        email: dict[str, Any] = {"enabled": True}
        email["smtp_host"] = _prompt("SMTP host", "smtp.example.com")
        email["smtp_port"] = _prompt_int("SMTP port", 587, 1, 65535)
        email["smtp_tls"] = _prompt_choice(
            "SMTP security", ["starttls", "ssl", "none"], "starttls"
        )
        email["smtp_user"] = _prompt("SMTP username (leave empty if none)", "")
        if email["smtp_user"]:
            email["smtp_password"] = _prompt("SMTP password", "")
        email["from_addr"] = _prompt("From address", "")
        to_addrs_str = _prompt("To addresses (comma-separated)", "")
        if to_addrs_str:
            email["to_addrs"] = [
                a.strip() for a in to_addrs_str.split(",") if a.strip()
            ]
        email["on_success"] = _prompt_bool("Notify on success?", False)
        email["on_failure"] = _prompt_bool("Notify on failure?", True)
        config_data["email"] = email

    if _prompt_bool("Configure webhook notifications?", False):
        webhook: dict[str, Any] = {"enabled": True}
        webhook["url"] = _prompt("Webhook URL", "")
        webhook["method"] = _prompt_choice(
            "HTTP method", ["POST", "GET", "PUT"], "POST"
        )
        webhook["on_success"] = _prompt_bool("Notify on success?", False)
        webhook["on_failure"] = _prompt_bool("Notify on failure?", True)
        config_data["webhook"] = webhook

    # Volumes
    print()
    print("-" * 40)
    print("  Volumes to Backup")
    print("-" * 40)

    volumes = []
    add_volume = True

    while add_volume:
        print()
        print(f"  Volume #{len(volumes) + 1}")

        volume_path = _prompt("Volume path (e.g., /home)", "")
        if not volume_path:
            if not volumes:
                print("  At least one volume is required.")
                continue
            break

        # Generate default prefix from path
        default_prefix = Path(volume_path).name or "root"
        snapshot_prefix = _prompt("Snapshot prefix", default_prefix)

        volume: dict[str, Any] = {
            "path": volume_path,
            "snapshot_prefix": snapshot_prefix,
            "targets": [],
        }

        # Targets for this volume
        print()
        print("  Add backup targets for this volume:")

        add_target = True
        while add_target:
            target_path = _prompt("  Target path (local or ssh://user@host:/path)", "")
            if not target_path:
                if not volume["targets"]:
                    print("  At least one target is required per volume.")
                    continue
                break

            target: dict[str, Any] = {"path": target_path}

            if target_path.startswith("ssh://"):
                target["ssh_sudo"] = _prompt_bool("  Use sudo on remote host?", False)
            elif target_path.startswith("/mnt/") or "usb" in target_path.lower():
                target["require_mount"] = _prompt_bool(
                    "  Require mount check (for external drives)?", True
                )

            volume["targets"].append(target)
            add_target = _prompt_bool("  Add another target?", False)

        volumes.append(volume)
        add_volume = _prompt_bool("Add another volume?", False)

    config_data["volumes"] = volumes

    # Generate the config
    print()
    print("-" * 40)
    print("  Configuration Complete")
    print("-" * 40)

    return _generate_config_from_wizard(config_data)


def execute_config(args: argparse.Namespace) -> int:
    """Execute the config command.

    Args:
        args: Parsed command line arguments

    Returns:
        Exit code
    """
    log_level = get_log_level(args)
    create_logger(False, level=log_level)

    action = getattr(args, "config_action", None)

    if action == "validate":
        return _validate_config(args)
    elif action == "init":
        return _init_config(args)
    elif action == "import":
        return _import_config(args)
    else:
        print("Usage: btrfs-backup-ng config <validate|init|import>")
        return 1


def _validate_config(args: argparse.Namespace) -> int:
    """Validate configuration file."""
    try:
        config_path = find_config_file(getattr(args, "config", None))
        if config_path is None:
            print("No configuration file found.")
            print("Searched locations:")
            print("  ~/.config/btrfs-backup-ng/config.toml")
            print("  /etc/btrfs-backup-ng/config.toml")
            return 1

        print(f"Validating: {config_path}")
        config, warnings = load_config(config_path)

        if warnings:
            print("")
            print("Warnings:")
            for warning in warnings:
                print(f"  - {warning}")

        print("")
        print("Configuration is valid.")
        print(f"  Volumes: {len(config.volumes)}")
        print(f"  Enabled: {len(config.get_enabled_volumes())}")

        total_targets = sum(len(v.targets) for v in config.volumes)
        print(f"  Targets: {total_targets}")

        return 0

    except ConfigError as e:
        print(f"Configuration error: {e}")
        return 1


def _init_config(args: argparse.Namespace) -> int:
    """Generate example configuration."""
    interactive = getattr(args, "interactive", False)
    output = getattr(args, "output", None)

    if interactive:
        # Check if stdout is a TTY for interactive mode
        if not sys.stdin.isatty():
            print("Error: Interactive mode requires a terminal (TTY)")
            return 1

        try:
            content = _run_interactive_wizard()
        except KeyboardInterrupt:
            print("\nConfiguration cancelled.")
            return 1
    else:
        content = generate_example_config()

    if output:
        # Check if file exists
        if os.path.exists(output) and interactive:
            if not _prompt_bool(f"\nFile {output} exists. Overwrite?", False):
                print("Aborted.")
                return 1

        try:
            with open(output, "w") as f:
                f.write(content)
            if interactive:
                print(f"\nConfiguration written to: {output}")
                print("Review and adjust the configuration, then run:")
                print(f"  btrfs-backup-ng config validate --config {output}")
            else:
                print(f"Example configuration written to: {output}")
        except OSError as e:
            print(f"Error writing file: {e}")
            return 1
    else:
        print(content)

    return 0


def _import_config(args: argparse.Namespace) -> int:
    """Import btrbk configuration."""
    from ..btrbk_import import import_btrbk_config

    btrbk_file = getattr(args, "btrbk_config", None)
    if not btrbk_file:
        print("Error: btrbk configuration file path required")
        return 1

    try:
        toml_content, warnings = import_btrbk_config(btrbk_file)
    except FileNotFoundError as e:
        print(f"Error: {e}")
        return 1
    except Exception as e:
        print(f"Error parsing btrbk config: {e}")
        return 1

    # Show warnings
    if warnings:
        print("# Conversion warnings:", file=sys.stderr)
        for warning in warnings:
            print(f"#   {warning}", file=sys.stderr)
        print("", file=sys.stderr)

    # Output TOML
    output = getattr(args, "output", None)
    if output:
        try:
            with open(output, "w") as f:
                f.write(toml_content)
            print(f"Configuration written to: {output}", file=sys.stderr)
            print("Review the file and adjust as needed.", file=sys.stderr)
        except OSError as e:
            print(f"Error writing file: {e}")
            return 1
    else:
        print(toml_content)

    if warnings:
        print("", file=sys.stderr)
        print(f"Conversion complete with {len(warnings)} warning(s).", file=sys.stderr)
        print(
            "Review the warnings above and adjust the configuration.", file=sys.stderr
        )

    return 0
