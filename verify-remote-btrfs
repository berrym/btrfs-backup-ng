#!/bin/bash
#
# verify-remote-btrfs - Script to verify a remote filesystem is BTRFS
#
# This script checks if a remote path is on a BTRFS filesystem
# by running various tests via SSH. It's useful to validate destinations
# before attempting btrfs snapshot transfers.
#

set -e

# Default values
IDENTITY_FILE=""
VERBOSE=false
USE_SUDO=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print usage information
function show_usage() {
    echo "Usage: $(basename $0) [options] <user@host:/path>"
    echo
    echo "Options:"
    echo "  -i, --identity <file>      SSH identity file"
    echo "  -s, --sudo                 Use sudo on remote host"
    echo "  -v, --verbose              Enable verbose output"
    echo "  -h, --help                 Show this help message"
    echo
    echo "Examples:"
    echo "  $(basename $0) user@remotehost:/path/to/check"
    echo "  $(basename $0) -i ~/.ssh/id_ed25519 -s user@remotehost:/path/to/check"
    echo
}

function log_info() {
    echo -e "[${BLUE}INFO${NC}] $1"
}

function log_success() {
    echo -e "[${GREEN}SUCCESS${NC}] $1"
}

function log_warning() {
    echo -e "[${YELLOW}WARNING${NC}] $1"
}

function log_error() {
    echo -e "[${RED}ERROR${NC}] $1" >&2
}

function verbose() {
    if $VERBOSE; then
        echo -e "[${BLUE}DEBUG${NC}] $1"
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -i|--identity)
            IDENTITY_FILE="$2"
            shift 2
            ;;
        -s|--sudo)
            USE_SUDO=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            if [[ -z "$REMOTE_PATH" ]]; then
                # Handle ssh:// prefix if present
                if [[ "$1" == ssh://* ]]; then
                    REMOTE_PATH="${1#ssh://}"
                else
                    REMOTE_PATH="$1"
                fi
                shift
            else
                log_error "Unexpected argument: $1"
                show_usage
                exit 1
            fi
            ;;
    esac
done

# Check for required arguments
if [[ -z "$REMOTE_PATH" ]]; then
    log_error "Missing required argument: remote path"
    show_usage
    exit 1
fi

# Check if remote path is in the correct format
if [[ ! "$REMOTE_PATH" =~ .*:.* ]]; then
    log_error "Remote path must be in format user@host:/path or host:/path"
    show_usage
    exit 1
fi

# Parse remote path
HOST_PART="${REMOTE_PATH%%:*}"
PATH_PART="${REMOTE_PATH#*:}"

if [[ "$HOST_PART" =~ .*@.* ]]; then
    USER_PART="${HOST_PART%%@*}"
    HOST_PART="${HOST_PART#*@}"
else
    USER_PART="$USER"
fi

verbose "User: $USER_PART"
verbose "Host: $HOST_PART"
verbose "Path: $PATH_PART"

# Check SSH_AUTH_SOCK if running as root
if [[ $EUID -eq 0 && -z "$SSH_AUTH_SOCK" && -n "$SUDO_USER" ]]; then
    log_warning "Running as root without SSH_AUTH_SOCK - attempting to fix"
    USER_SSH_AUTH_SOCK=$(sudo -u "$SUDO_USER" printenv SSH_AUTH_SOCK 2>/dev/null)
    if [[ -n "$USER_SSH_AUTH_SOCK" ]]; then
        export SSH_AUTH_SOCK="$USER_SSH_AUTH_SOCK"
        log_success "Fixed SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
    else
        log_error "Cannot get SSH_AUTH_SOCK from original user - SSH authentication will likely fail"
        log_error "Please run with: sudo SSH_AUTH_SOCK=\$SSH_AUTH_SOCK $(basename $0) ..."
    fi
fi

# Set up SSH command
SSH_OPTS="-o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10"
if [[ -n "$IDENTITY_FILE" ]]; then
    SSH_OPTS="$SSH_OPTS -i $IDENTITY_FILE"
fi

sudo_cmd=""
if $USE_SUDO; then
    sudo_cmd="sudo"
fi

log_info "Verifying remote filesystem type for $REMOTE_PATH..."

# Test 1: Use stat command
verbose "Test 1: Using stat -f to check filesystem type"
fs_type=$(ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd stat -f -c %T $PATH_PART" 2>/dev/null || echo "")

if [[ "$fs_type" == "btrfs" ]]; then
    log_success "Remote filesystem is BTRFS (verified with stat)"
    exit 0
else
    verbose "stat result: ${fs_type:-command failed}"
fi

# Test 2: Use df command
verbose "Test 2: Using df -T to check filesystem type"
df_output=$(ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd df -T $PATH_PART" 2>/dev/null || echo "")

if [[ "$df_output" == *"btrfs"* ]]; then
    log_success "Remote filesystem is BTRFS (verified with df)"
    echo "$df_output" | head -2
    exit 0
else
    verbose "df output: ${df_output:-command failed}"
fi

# Test 3: Try btrfs commands
verbose "Test 3: Testing if btrfs commands work on the path"
btrfs_output=$(ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd btrfs filesystem usage $PATH_PART" 2>/dev/null || echo "")

if [[ -n "$btrfs_output" && "$btrfs_output" != *"ERROR"* ]]; then
    log_success "Remote filesystem is BTRFS (btrfs commands work)"
    exit 0
else
    verbose "btrfs command output: ${btrfs_output:-command failed}"
fi

# Test 4: Check if subvolume commands work
verbose "Test 4: Testing if btrfs subvolume commands work on the path"
subvol_output=$(ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd btrfs subvolume list -o $PATH_PART" 2>/dev/null || echo "")

if [[ -n "$subvol_output" ]]; then
    log_success "Remote filesystem is BTRFS (subvolume commands work)"
    exit 0
else
    verbose "subvolume command output: ${subvol_output:-command failed}"
fi

# If we get here, all tests failed
log_error "Remote filesystem at $REMOTE_PATH is NOT BTRFS or is inaccessible"
log_error "Snapshots can only be transferred to BTRFS filesystems"

# Display filesystem info
echo "----------------------------------------"
echo "Remote filesystem information:"
ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd df -T $PATH_PART" 2>/dev/null || echo "Cannot get filesystem information"
echo "----------------------------------------"
echo "Path information:"
ssh $SSH_OPTS $USER_PART@$HOST_PART "$sudo_cmd ls -ld $PATH_PART" 2>/dev/null || echo "Cannot access path"
echo "----------------------------------------"

exit 1